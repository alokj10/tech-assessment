{"version":3,"sources":["../../src/commons/Evaluator.js"],"names":["Evaluator","Evaluate","responseEntity","Promise","resolve","reject","evaluationResults","response_meta","mcqs","length","candidateScore","totalScore","map","mcqItem","index","isCorrect","correctAnswerKeys","mcq","mcq_meta","choices","choiceItem","idx","push","key","candidateResponseKeys","candidateResponse","responseKeys","i","indexOf","parseScore","score","console","log","passingPercentage","Constants","PassingPercentage","scorePercentage","result","total_score","candidate_score","evaluation_status","error","EvaluateRegisteredTestResponse","responseMcqs","dbMcqs","correctChoices","responseChoices","correctKeys","mcqId","id","choice","mcqScore","responseKey","evaluationResult","forEach","responseChoice","matchingChoice","filter","item","res","correctChoice","completedOn","stringValue","isNaN","DefaultScore","parseInt"],"mappings":"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","file":"Evaluator.js","sourcesContent":["import { getCurrentDateTime } from './HelperFunctions';\r\nimport { Constants } from './ServerConfig';\r\n\r\nclass Evaluator {\r\n    \r\n    Evaluate = (responseEntity) => {\r\n        return new Promise((resolve, reject) => {\r\n            try {\r\n         \r\n                let evaluationResults = [];\r\n                if(responseEntity && \r\n                    responseEntity.response_meta.mcqs && \r\n                    responseEntity.response_meta.mcqs.length > 0) {\r\n                    \r\n                    let candidateScore = 0;\r\n                    let totalScore = 0;\r\n        \r\n                    responseEntity.response_meta.mcqs.map((mcqItem, index) => {\r\n                        mcqItem.isCorrect = true;\r\n                        let correctAnswerKeys = [];\r\n                        mcqItem.mcq.mcq_meta.choices.map((choiceItem, idx) => {\r\n                            if(choiceItem.isCorrect) {\r\n                                correctAnswerKeys.push(choiceItem.key);\r\n                            }\r\n                        });\r\n                        let candidateResponseKeys = mcqItem.candidateResponse.responseKeys;\r\n                        for(var i = 0; i < correctAnswerKeys.length; i++) {\r\n                            if(candidateResponseKeys.indexOf(correctAnswerKeys[i]) < 0) {\r\n                                mcqItem.isCorrect = false;\r\n                                break;\r\n                            }\r\n                        }\r\n                        if(mcqItem.isCorrect) {\r\n                            candidateScore += 0 + this.parseScore(mcqItem.mcq.mcq_meta.score);\r\n                        }\r\n                        totalScore += 0 + this.parseScore(mcqItem.mcq.mcq_meta.score);\r\n                        console.log('totalScore', totalScore);\r\n                    });\r\n                    \r\n                    let passingPercentage = Constants.PassingPercentage;\r\n                    let scorePercentage = (candidateScore / totalScore) * 100;\r\n                    let result = scorePercentage >= passingPercentage ?\r\n                                                        'CLEARED' :\r\n                                                        'FAILED';\r\n                    responseEntity.response_meta.totalScore = totalScore;\r\n                    responseEntity.response_meta.candidateScore = candidateScore;\r\n                    responseEntity.response_meta.scorePercentage = scorePercentage;\r\n                    responseEntity.response_meta.result = result;\r\n\r\n                    responseEntity.total_score = totalScore;\r\n                    responseEntity.candidate_score = candidateScore;\r\n                    responseEntity.result = result;                                                                \r\n                    responseEntity.evaluation_status = 'COMPLETED';\r\n        \r\n                }\r\n                \r\n                resolve(responseEntity);\r\n\r\n            } catch (error) {\r\n                reject(error);\r\n            }\r\n        });\r\n    }\r\n\r\n    EvaluateRegisteredTestResponse = (responseMcqs, dbMcqs) => {\r\n        let correctChoices = [];\r\n        let responseChoices = [];\r\n        dbMcqs.map((mcqItem) => {\r\n            let correctKeys = '';\r\n            mcqItem.mcq_meta.choices.map((choiceItem) => {\r\n                if(choiceItem.isCorrect) {\r\n                    correctKeys += choiceItem.key;\r\n                }\r\n            })\r\n            correctChoices.push({\r\n                mcqId: mcqItem.id,\r\n                choice: correctKeys,\r\n                mcqScore: !mcqItem.mcq_meta.score ? 10 : mcqItem.mcq_meta.score\r\n            })\r\n        })\r\n        responseMcqs.map((mcqItem) => {\r\n            let correctKeys = '';\r\n            mcqItem.candidateResponse.responseKeys.map((responseKey) => {\r\n                correctKeys += responseKey;\r\n            })\r\n            responseChoices.push({\r\n                mcqId: mcqItem.mcqId,\r\n                choice: correctKeys,\r\n                responseKeys: mcqItem.candidateResponse.responseKeys\r\n            })\r\n        })\r\n\r\n        let evaluationResult = {\r\n            totalScore: 0,\r\n            candidateScore: 0,\r\n            scorePercentage: 0,\r\n            result: ''\r\n        };\r\n        responseChoices.forEach((responseChoice) => {\r\n            let matchingChoice = correctChoices.filter((item) => {\r\n                return item.mcqId === responseChoice.mcqId;\r\n            })\r\n            let res = {\r\n                mcqId: responseChoice.mcqId,\r\n                responseKeys: responseChoice.responseKeys,\r\n            }\r\n            if(matchingChoice && matchingChoice.length > 0) {\r\n                let correctChoice = matchingChoice[0];\r\n                res.isCorrect = responseChoice.choice === correctChoice.choice;\r\n                evaluationResult.candidateScore += res.isCorrect ?  correctChoice.mcqScore : 0;\r\n                evaluationResult.totalScore +=  correctChoice.mcqScore;\r\n            }\r\n            else {\r\n                res.isCorrect = false;\r\n            }\r\n        });\r\n        \r\n        let passingPercentage = Constants.PassingPercentage;\r\n        evaluationResult.completedOn = getCurrentDateTime();\r\n        evaluationResult.scorePercentage = (evaluationResult.candidateScore / evaluationResult.totalScore) * 100;\r\n        evaluationResult.result = evaluationResult.scorePercentage >= passingPercentage ?\r\n                                                    'CLEARED' :\r\n                                                    'FAILED';\r\n        return evaluationResult;\r\n    }\r\n\r\n    parseScore = (stringValue) => {\r\n        if(isNaN(stringValue)){\r\n            return Constants.DefaultScore;\r\n        }\r\n        return parseInt(stringValue);\r\n    }\r\n\r\n}\r\n\r\nexport default Evaluator;"]}