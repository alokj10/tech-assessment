{"version":3,"sources":["../../src/commons/Evaluator.js"],"names":["Evaluator","Evaluate","responseEntity","Promise","resolve","reject","evaluationResults","response_meta","mcqs","length","candidateScore","totalScore","map","mcqItem","index","isCorrect","correctAnswerKeys","mcq","mcq_meta","choices","choiceItem","idx","push","key","candidateResponseKeys","candidateResponse","responseKeys","i","indexOf","parseScore","score","console","log","passingPercentage","Constants","PassingPercentage","scorePercentage","result","error","stringValue","isNaN","DefaultScore","parseInt"],"mappings":";;;;;;AAAA;;;;IAEMA,S;;;;;SAEFC,Q,GAAW,UAACC,cAAD,EAAoB;AAC3B,eAAO,IAAIC,OAAJ,CAAY,UAACC,OAAD,EAAUC,MAAV,EAAqB;AACpC,gBAAI;;AAEA,oBAAIC,oBAAoB,EAAxB;AACA,oBAAGJ,kBACCA,eAAeK,aAAf,CAA6BC,IAD9B,IAECN,eAAeK,aAAf,CAA6BC,IAA7B,CAAkCC,MAAlC,GAA2C,CAF/C,EAEkD;;AAE9C,wBAAIC,iBAAiB,CAArB;AACA,wBAAIC,aAAa,CAAjB;;AAEAT,mCAAeK,aAAf,CAA6BC,IAA7B,CAAkCI,GAAlC,CAAsC,UAACC,OAAD,EAAUC,KAAV,EAAoB;AACtDD,gCAAQE,SAAR,GAAoB,IAApB;AACA,4BAAIC,oBAAoB,EAAxB;AACAH,gCAAQI,GAAR,CAAYC,QAAZ,CAAqBC,OAArB,CAA6BP,GAA7B,CAAiC,UAACQ,UAAD,EAAaC,GAAb,EAAqB;AAClD,gCAAGD,WAAWL,SAAd,EAAyB;AACrBC,kDAAkBM,IAAlB,CAAuBF,WAAWG,GAAlC;AACH;AACJ,yBAJD;AAKA,4BAAIC,wBAAwBX,QAAQY,iBAAR,CAA0BC,YAAtD;AACA,6BAAI,IAAIC,IAAI,CAAZ,EAAeA,IAAIX,kBAAkBP,MAArC,EAA6CkB,GAA7C,EAAkD;AAC9C,gCAAGH,sBAAsBI,OAAtB,CAA8BZ,kBAAkBW,CAAlB,CAA9B,IAAsD,CAAzD,EAA4D;AACxDd,wCAAQE,SAAR,GAAoB,KAApB;AACA;AACH;AACJ;AACD,4BAAGF,QAAQE,SAAX,EAAsB;AAClBL,8CAAkB,IAAI,MAAKmB,UAAL,CAAgBhB,QAAQI,GAAR,CAAYC,QAAZ,CAAqBY,KAArC,CAAtB;AACH;AACDnB,sCAAc,IAAI,MAAKkB,UAAL,CAAgBhB,QAAQI,GAAR,CAAYC,QAAZ,CAAqBY,KAArC,CAAlB;AACAC,gCAAQC,GAAR,CAAY,YAAZ,EAA0BrB,UAA1B;AACH,qBApBD;;AAsBA,wBAAIsB,oBAAoBC,wBAAUC,iBAAlC;AACAjC,mCAAeK,aAAf,CAA6BI,UAA7B,GAA0CA,UAA1C;AACAT,mCAAeK,aAAf,CAA6BG,cAA7B,GAA8CA,cAA9C;AACAR,mCAAeK,aAAf,CAA6B6B,eAA7B,GAAgD1B,iBAAiBC,UAAlB,GAAgC,GAA/E;AACAT,mCAAeK,aAAf,CAA6B8B,MAA7B,GAAsCnC,eAAeK,aAAf,CAA6B6B,eAA7B,IAAgDH,iBAAhD,GACM,SADN,GAEM,QAF5C;AAIH;;AAED7B,wBAAQF,cAAR;AAEH,aA5CD,CA4CE,OAAOoC,KAAP,EAAc;AACZjC,uBAAOiC,KAAP;AACH;AACJ,SAhDM,CAAP;AAiDH,K;;SAEDT,U,GAAa,UAACU,WAAD,EAAiB;AAC1B,YAAGC,MAAMD,WAAN,CAAH,EAAsB;AAClB,mBAAOL,wBAAUO,YAAjB;AACH;AACD,eAAOC,SAASH,WAAT,CAAP;AACH,K;;;kBAIUvC,S","file":"Evaluator.js","sourcesContent":["import { Constants } from './ServerConfig';\r\n\r\nclass Evaluator {\r\n    \r\n    Evaluate = (responseEntity) => {\r\n        return new Promise((resolve, reject) => {\r\n            try {\r\n         \r\n                let evaluationResults = [];\r\n                if(responseEntity && \r\n                    responseEntity.response_meta.mcqs && \r\n                    responseEntity.response_meta.mcqs.length > 0) {\r\n                    \r\n                    let candidateScore = 0;\r\n                    let totalScore = 0;\r\n        \r\n                    responseEntity.response_meta.mcqs.map((mcqItem, index) => {\r\n                        mcqItem.isCorrect = true;\r\n                        let correctAnswerKeys = [];\r\n                        mcqItem.mcq.mcq_meta.choices.map((choiceItem, idx) => {\r\n                            if(choiceItem.isCorrect) {\r\n                                correctAnswerKeys.push(choiceItem.key);\r\n                            }\r\n                        });\r\n                        let candidateResponseKeys = mcqItem.candidateResponse.responseKeys;\r\n                        for(var i = 0; i < correctAnswerKeys.length; i++) {\r\n                            if(candidateResponseKeys.indexOf(correctAnswerKeys[i]) < 0) {\r\n                                mcqItem.isCorrect = false;\r\n                                break;\r\n                            }\r\n                        }\r\n                        if(mcqItem.isCorrect) {\r\n                            candidateScore += 0 + this.parseScore(mcqItem.mcq.mcq_meta.score);\r\n                        }\r\n                        totalScore += 0 + this.parseScore(mcqItem.mcq.mcq_meta.score);\r\n                        console.log('totalScore', totalScore);\r\n                    });\r\n                    \r\n                    let passingPercentage = Constants.PassingPercentage;\r\n                    responseEntity.response_meta.totalScore = totalScore;\r\n                    responseEntity.response_meta.candidateScore = candidateScore;\r\n                    responseEntity.response_meta.scorePercentage = (candidateScore / totalScore) * 100;\r\n                    responseEntity.response_meta.result = responseEntity.response_meta.scorePercentage >= passingPercentage ?\r\n                                                                'CLEARED' :\r\n                                                                'FAILED';\r\n        \r\n                }\r\n                \r\n                resolve(responseEntity);\r\n\r\n            } catch (error) {\r\n                reject(error);\r\n            }\r\n        });\r\n    }\r\n\r\n    parseScore = (stringValue) => {\r\n        if(isNaN(stringValue)){\r\n            return Constants.DefaultScore;\r\n        }\r\n        return parseInt(stringValue);\r\n    }\r\n\r\n}\r\n\r\nexport default Evaluator;"]}